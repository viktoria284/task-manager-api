# Task Manager REST API

Лабораторная работа **«Проектирование и реализация REST API»**.

Цель работы: Закрепить принципы проектирования REST API: простота, стабильность, версионность, идемпотентность, ограничение частоты запросов и документация.

(описание предметной области, 
конечные точки API, 
примеры запросов и ответов, выводы, обоснование выбора способа аутентификации).

## 1. Предметная область

Предметная область — **система управления задачами**.

### Сущности и связи

**User** (пользователь):

- `id` — идентификатор;
- `email` — логин, уникальный;
- `password_hash` — хэш пароля;
- `full_name` — ФИО;
- `created_at` — дата регистрации.

**Task** (задача):

- `id` — идентификатор задачи;
- `owner_id` — внешний ключ на `users.id`;
- `title` — короткий заголовок;
- `description` — описание;
- `status` — состояние задачи: `todo | in_progress | done`;
- `priority` — приоритет задачи (в v2 API): `low | medium | high`;
- `due_date` — срок выполнения (опционально);
- `created_at`, `updated_at` — даты создания и последнего обновления.

**Связь:** один пользователь может иметь много задач (связь 1:N).

Реализация: `app/db/models.py` (SQLAlchemy).

---

## 2. Проектирование API (ресурсы и конечные точки)

Базовая структура URL:  
`/api/{version}/{resource}`

Ресурсы:

- `auth` — работа с пользователями и токенами;
- `tasks` — управление задачами.

### Примеры конечных точек (v1)

**Auth v1**

- `POST /api/v1/auth/register` — регистрация пользователя  
- `POST /api/v1/auth/login` — логин, выдача JWT-токена  

**Tasks v1**

- `GET /api/v1/tasks` — список задач текущего пользователя  
- `POST /api/v1/tasks` — создать задачу  
- `GET /api/v1/tasks/{id}` — получить задачу  
- `PUT /api/v1/tasks/{id}` — изменить задачу  
- `DELETE /api/v1/tasks/{id}` — удалить задачу  


Структура API простая и предсказуемая: ресурсы во множественном числе, глагол задаётся HTTP-методом (GET/POST/PUT/DELETE).

---

## 3. Версионность и аддитивные изменения

Реализованы две версии API:

- **v1** — базовая стабильная версия;
- **v2** — расширенная версия без ломки v1.

### Отличия v2 (аддитивное изменение)

**Tasks v2**

- `POST /api/v2/tasks` — при создании задачи можно указать `priority`;
- `GET /api/v2/tasks` — возвращает задачи с полем `priority`.

В v1 поле `priority` отсутствует в контракте (`TaskV1`),  
в v2 добавлено (`TaskV2`), при этом старые клиенты, использующие `/api/v1`, продолжают работать без изменений.

### Ломающие изменения

Ломающими были бы, например:

- переименование поля `status` в `state`;
- изменение типа `id` (int → string);
- удаление поля `description`.

Такие изменения в существующих версиях API **не выполнялись** — вместо этого сделана отдельная версия v2 с аддитивным расширением.

---

## 4. Аутентификация (JWT)

Выбран способ аутентификации: **JWT (JSON Web Token)** со схемой `Bearer`.

Причины выбора:

- **Stateless**: сервер не хранит сессии, достаточно секретного ключа.
- **Удобно для REST**: токен передаётся в заголовке `Authorization`.
- **Расширяемость**: легко использовать в распределённых системах и микросервисах.

### Основные моменты

- При логине пользователь отправляет `email` и `password` на  
  `POST /api/v1/auth/login`.
- В ответ сервер выдаёт объект:

  ```json
  {
    "access_token": "<JWT>",
    "token_type": "bearer"
  }
- При обращении к защищённым эндпоинтам используется заголовок:

  ```http
  Authorization: Bearer <JWT>

Реализация: app/api/deps.py, app/api/v1/endpoints/auth.py.

---

## 5. Идемпотентность

Идемпотентность реализована для операций создания задач:

- `POST /api/v1/tasks`
- `POST /api/v2/tasks`

Используется заголовок:

```http
Idempotency-Key: <уникальный_ключ_операции>
```

### Поведение:

- Первый запрос с новым Idempotency-Key → создаётся задача, ответ сохраняется во внутреннем хранилище.
- Повторный запрос с тем же Idempotency-Key (тем же пользователем и по тому же пути) →
возвращается ранее сохранённый ответ, дубликат задачи не создаётся.

Реализация: app/core/idempotency.py + зависимости в ручках создания задач.

---

## 6. Ограничение частоты запросов (rate limiting)

Для всех основных конечных точек включён простой rate limiting по IP.
- Ведётся счётчик запросов на окно времени (например, N запросов в минуту).
- При превышении лимита возвращается 429 Too Many Requests.

Ответы содержат заголовки:

- X-Limit-Remaining — сколько запросов осталось в текущем окне;
- Retry-After — через сколько секунд можно повторить запрос (при 429).

Реализация:

- app/api/deps.py — логика подсчёта запросов (rate_limit_dependency);
- app/main.py — middleware add_rate_limit_headers, добавляющее заголовки.

---

## 7. Документация (OpenAPI / Swagger)

Документация генерируется автоматически на основе FastAPI и Pydantic-схем.

- Swagger UI: http://127.0.0.1:8000/docs
- OpenAPI JSON: http://127.0.0.1:8000/openapi.json

В документации отражены:

- обе версии API (/api/v1, /api/v2);
- все конечные точки (auth, tasks);
- схемы запросов и ответов (UserCreate, UserLogin, TaskCreate, TaskUpdate, TaskV1, TaskV2, Token и др.);
- заголовки Authorization и Idempotency-Key.

---

## 8. Инструкция по запуску

Требования: Python 3.10+, PostgreSQL, pip / venv

### Установка

```bash
python -m venv venv
# Windows:
venv\Scripts\activate
# Linux/Mac:
# source venv/bin/activate

pip install -r requirements.txt
```

Создать базу данных в PostgreSQL, например:
```sql
CREATE DATABASE task_manager;
```

Настройки подключения — в app/core/config.py (или через переменные окружения):
```env
POSTGRES_USER=postgres
POSTGRES_PASSWORD=your_password
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_DB=task_manager
```

### Запуск
```bash
uvicorn app.main:app --reload
```

### Проверка:

Swagger UI: http://127.0.0.1:8000/docs

Любой защищённый эндпоинт (/api/v1/tasks) доступен только после:
1. POST /api/v1/auth/register
2. POST /api/v1/auth/login
3. Указания Authorization: Bearer <JWT> в запросах.





**«Лабораторная работа №2: расширенные возможности (пагинация, опциональные поля, внутренние API)»** 
