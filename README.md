# Task Manager REST API

Лабораторная работа №1 **«Проектирование и реализация REST API»**.

Цель работы: Закрепить принципы проектирования REST API: простота, стабильность, версионность, идемпотентность, ограничение частоты запросов и документация.

## 1. Предметная область

Предметная область — **система управления задачами**.

### Сущности и связи

**User** (пользователь):

- `id` — идентификатор;
- `email` — логин, уникальный;
- `password_hash` — хэш пароля;
- `full_name` — ФИО;
- `created_at` — дата регистрации.

**Task** (задача):

- `id` — идентификатор задачи;
- `owner_id` — внешний ключ на `users.id`;
- `title` — короткий заголовок;
- `description` — описание;
- `status` — состояние задачи: `todo | in_progress | done`;
- `priority` — приоритет задачи (в v2 API): `low | medium | high`;
- `due_date` — срок выполнения (опционально);
- `created_at`, `updated_at` — даты создания и последнего обновления.

**Связь:** один пользователь может иметь много задач (связь 1:N).

Реализация: `app/db/models.py` (SQLAlchemy).

---

## 2. Проектирование API (ресурсы и конечные точки)

Базовая структура URL:  
`/api/{version}/{resource}`

Ресурсы:

- `auth` — работа с пользователями и токенами;
- `tasks` — управление задачами.

### Примеры конечных точек (v1)

**Auth v1**

- `POST /api/v1/auth/register` — регистрация пользователя  
- `POST /api/v1/auth/login` — логин, выдача JWT-токена  

**Tasks v1**

- `GET /api/v1/tasks` — список задач текущего пользователя  
- `POST /api/v1/tasks` — создать задачу  
- `GET /api/v1/tasks/{id}` — получить задачу  
- `PUT /api/v1/tasks/{id}` — изменить задачу  
- `DELETE /api/v1/tasks/{id}` — удалить задачу  


Структура API простая и предсказуемая: ресурсы во множественном числе, глагол задаётся HTTP-методом (GET/POST/PUT/DELETE).

---

## 3. Версионность и аддитивные изменения

Реализованы две версии API:

- **v1** — базовая стабильная версия;
- **v2** — расширенная версия без ломки v1.

### Отличия v2 (аддитивное изменение)

**Tasks v2**

- `POST /api/v2/tasks` — при создании задачи можно указать `priority`;
- `GET /api/v2/tasks` — возвращает задачи с полем `priority`.

В v1 поле `priority` отсутствует в контракте (`TaskV1`),  
в v2 добавлено (`TaskV2`), при этом старые клиенты, использующие `/api/v1`, продолжают работать без изменений.

### Ломающие изменения

Ломающими были бы, например:

- переименование поля `status` в `state`;
- изменение типа `id` (int → string);
- удаление поля `description`.

Такие изменения в существующих версиях API **не выполнялись** — вместо этого сделана отдельная версия v2 с аддитивным расширением.

---

## 4. Аутентификация (JWT)

Выбран способ аутентификации: **JWT (JSON Web Token)** со схемой `Bearer`.

Причины выбора:

- **Stateless**: сервер не хранит сессии, достаточно секретного ключа.
- **Удобно для REST**: токен передаётся в заголовке `Authorization`.
- **Расширяемость**: легко использовать в распределённых системах и микросервисах.

### Основные моменты

- При логине пользователь отправляет `email` и `password` на  
  `POST /api/v1/auth/login`.
- В ответ сервер выдаёт объект:

  ```json
  {
    "access_token": "<JWT>",
    "token_type": "bearer"
  }
- При обращении к защищённым эндпоинтам используется заголовок:

  ```http
  Authorization: Bearer <JWT>

Реализация: `app/api/deps.py`, `app/api/v1/endpoints/auth.py`.

---

## 5. Идемпотентность

Идемпотентность реализована для операций создания задач:

- `POST /api/v1/tasks`
- `POST /api/v2/tasks`

Используется заголовок:

```http
Idempotency-Key: <уникальный_ключ_операции>
```

### Поведение:

- Первый запрос с новым Idempotency-Key → создаётся задача, ответ сохраняется во внутреннем хранилище.
- Повторный запрос с тем же Idempotency-Key (тем же пользователем и по тому же пути) → возвращается ранее сохранённый ответ, дубликат задачи не создаётся.

Реализация: `app/core/idempotency.py` + зависимости в ручках создания задач.

---

## 6. Ограничение частоты запросов (rate limiting)

Для всех основных конечных точек включён простой rate limiting по IP.
- Ведётся счётчик запросов на окно времени (например, N запросов в минуту).
- При превышении лимита возвращается `429 Too Many Requests`.

Ответы содержат заголовки:

- `X-Limit-Remaining` — сколько запросов осталось в текущем окне;
- `Retry-After` — через сколько секунд можно повторить запрос (при 429).

Реализация:

- `app/api/deps.py` — логика подсчёта запросов (`rate_limit_dependency`);
- `app/main.py` — middleware `add_rate_limit_headers`, добавляющее заголовки.

---

## 7. Документация (OpenAPI / Swagger)

Документация генерируется автоматически на основе FastAPI и Pydantic-схем.

- Swagger UI: `http://127.0.0.1:8000/docs`
- OpenAPI JSON: `http://127.0.0.1:8000/openapi.json`

В документации отражены:

- обе версии API (`/api/v1`, `/api/v2`);
- все конечные точки (`auth`, `tasks`);
- схемы запросов и ответов (`UserCreate`, `UserLogin`, `TaskCreate`, `TaskUpdate`, `TaskV1`, `TaskV2`, `Token` и др.);
- заголовки `Authorization` и `Idempotency-Key`.

---

## 8. Инструкция по запуску

Требования: Python 3.10+, PostgreSQL, `pip` / `venv`

### Установка

```bash
python -m venv venv
# Windows:
venv\Scripts\activate
# Linux/Mac:
# source venv/bin/activate

pip install -r requirements.txt
```

Создать базу данных в PostgreSQL, например:
```sql
CREATE DATABASE task_manager;
```

Настройки подключения — в `app/core/config.py` (или через переменные окружения):
```env
POSTGRES_USER=postgres
POSTGRES_PASSWORD=your_password
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_DB=task_manager
```

### Запуск
```bash
uvicorn app.main:app --reload
```

### Проверка:

Swagger UI: `http://127.0.0.1:8000/docs`

Любой защищённый эндпоинт (`/api/v1/tasks`) доступен только после:
1. `POST /api/v1/auth/register`
2. `POST /api/v1/auth/login`
3. Указания `Authorization: Bearer <JWT>` в запросах.


---

**Лабораторная работа №2: «Продвинутые принципы проектирования REST API»** 

Цель работы: закрепить и расширить навыки проектирования REST API: идемпотентность, безопасность, лимиты, пагинация, опциональные поля и внутренние API.

---

## 1. Безопасность и лимиты

В рамках ЛР2 были использованы и расширены возможности из ЛР1:

- Защита API остаётся на основе JWT:
  - все операции с задачами (`/api/v1/tasks`, `/api/v2/tasks`) и внутренний API (`/api/v2/internal/...`) доступны только аутентифицированному пользователю;
  - аутентификация реализована через зависимость `get_current_user` (файл `app/api/deps.py`).
- Ограничение частоты запросов (rate limiting) применяется ко всем основным конечным точкам:
  - логика — `rate_limit_dependency` в `app/api/deps.py`;
  - заголовки `X-Limit-Remaining` и `Retry-After` добавляются middleware `add_rate_limit_headers` в `app/main.py`.

---

## 2. Пагинация

Для конечных точек, возвращающих списки задач, реализована пагинация через параметры `limit` и `offset`:

- `GET /api/v1/tasks?limit=20&offset=0`
- `GET /api/v2/tasks?limit=20&offset=0`

По умолчанию используются значения:

- `limit = 20`
- `offset = 0`

В коде используется подход `limit/offset`, который:

- естественно ложится на SQL и SQLAlchemy (`.limit(limit).offset(offset)`);
- не ломает старое поведение: при отсутствии параметров эндпоинты работают как в ЛР1;
- достаточно прост и нагляден для учебного проекта.

---

## 3. Опциональные поля (параметр `include`)

Для версии v2 добавлен отдельный эндпоинт с возможностью выбора полей ответа:

- `GET /api/v2/tasks/fields`

Параметры:

- `include` — список полей через запятую, например:  
  `include=title,status,priority`
- также поддерживаются `limit`, `offset`, `status_filter`, `priority_filter`.

Поведение:

- если `include` не указан — эндпоинт возвращает полную задачу в формате `TaskV2` (как `GET /api/v2/tasks`);
- если `include` указан — для каждой задачи формируется словарь только из перечисленных полей.

Пример запроса:

```http
GET /api/v2/tasks/fields?include=title,status,priority
Authorization: Bearer <JWT>
```
Пример ответа:

```json
{
  "title": "Сделать отчёт",
  "status": "todo",
  "priority": "high"
}
```

---

## 4. Внутренний API

В рамках ЛР2 добавлен внутренний эндпоинт для служебной статистики:
- `GET /api/v2/internal/stats`

Ответ содержит агрегированные данные:

```json
{
  "users_count": 2,
  "tasks_count": 10,
  "tasks_by_status": {
    "todo": 5,
    "in_progress": 3,
    "done": 2
  }
}
```

Особенности внутреннего API:

- предназначен для внутренних сервисов, админки или мониторинга, а не для обычного клиента;
- возвращает агрегированную статистику по всей системе, а не отдельные сущности;
- формат ответа может изменяться чаще, не затрагивая публичный контракт для задач (`/api/v1/tasks`, `/api/v2/tasks`).

Эндпоинт защищён тем же механизмом JWT и использует общий rate limiting.

---

## 5. Документация и совместимость

Документация OpenAPI (Swagger) обновляется автоматически и включает новые возможности:

- в `GET /api/v1/tasks` и `GET /api/v2/tasks` появились параметры `limit` и `offset`;
- для `GET /api/v2/tasks/fields` задокументирован параметр `include`;
- для `GET /api/v2/internal/stats` описан формат ответа со статистикой.

Swagger UI остаётся доступен по адресу:
- `http://127.0.0.1:8000/docs`

Совместимость:
- все эндпоинты ЛР1 продолжают работать в прежнем формате;
- версия `/api/v1` не меняла контракт;
- новые возможности добавлены в `/api/v2` и внутренний `/api/v2/internal/...` без ломки существующих клиентов.

---

## 6. Примеры запросов (ЛР2)

Пагинация задач v2:

```http
GET /api/v2/tasks?limit=5&offset=5
Authorization: Bearer <JWT>
```

Выбор полей задачи:

```http
GET /api/v2/tasks/fields?include=title,status,priority
Authorization: Bearer <JWT>
```

Внутренняя статистика:

```http
GET /api/v2/internal/stats
Authorization: Bearer <JWT>
```